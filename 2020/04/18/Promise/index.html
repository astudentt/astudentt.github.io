<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="tan y m">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Promise 对象理解">
  <meta property="og:description" content="">
  <meta property="og:site_name" content="小 T a n g？ 爱生活～～～">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="小 T a n g？ 爱生活～～～" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>小 T a n g？ 爱生活～～～</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Promise 对象理解</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/<your-github-username>">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:<your-email-address>">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By tan y m</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-04-18</span>
            <span class="time">21:34:11</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/js/">js</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/js/">#js</a> <a class="tag" href="/tags/vue/">#vue</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>Promise 是异步编程的一种解决方案,一起了解Promise 对象吧。<br><a id="more"></a></p>
<ol>
<li>promise 是什么<br> Promise 是异步编程的一种解决方案</li>
<li>异步是什么<br> JS异步是指在进行某些需要耗时不会立即返回结果的操作时，不会阻塞后面的操作，一旦该耗时的操作完成时，则会通知需要调用其结果的函数来做后续处理。这是一种异步非阻塞的操作，也就是说任务的排列顺序和执行任务是不一致的。</li>
<li>为什么要有Promise，他解决了什么问题<br> 比传统的异步解决方案——回调函数和事件——更合理和更强大，回调函数会出现“回调地狱”等问题，在代码的可读性、可维护性、易读性都有很大的问题。<br> 回调地狱： 回调函数内部多层嵌套回调函数。</li>
<li>promise特点<br>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
<li>promise的优缺点<br> 优点：<ul>
<li>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</li>
<li>Promise对象提供统一的接口，使得控制异步操作更加容易。<br>缺点：</li>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li>
</ul>
</li>
<li><p>promise 使用方法<br>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。<br>下面代码创造了一个Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</span><br></pre></td></tr></table></figure>
</li>
<li><p>promise相关方法</p>
<ul>
<li><p>promise.all</p>
<p>方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p>
</li>
<li><p>promise.race</p>
<p>方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p>
</li>
</ul>
</li>
<li><p>如何js实现Promise相关方法</p>
</li>
</ol>
<p>promise.all<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static all(promiseArr) &#123;</span><br><span class="line">    let index = 0</span><br><span class="line">    let result = []</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">        promiseArr.forEach((p, i) =&gt; &#123;</span><br><span class="line">            //Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">            MyPromise.resolve(p).then(</span><br><span class="line">                val =&gt; &#123;</span><br><span class="line">                    index++</span><br><span class="line">                    result[i] = val</span><br><span class="line">                    if (index === promiseArr.length) &#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>promise.race<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//静态的race方法</span><br><span class="line">static race(promiseArr) &#123;</span><br><span class="line">    return new MyPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">        //同时执行Promise,如果有一个Promise的状态发生改变,就变更新MyPromise的状态</span><br><span class="line">        for (let p of promiseArr) &#123;</span><br><span class="line">            MyPromise.resolve(p).then(  //Promise.resolve(p)用于处理传入值不为Promise的情况</span><br><span class="line">                value =&gt; &#123;</span><br><span class="line">                    resolve(value)        //注意这个resolve是上边new MyPromise的</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Promise相关面试题目</li>
</ol>
<p>题目一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure></p>
<p>答案是： 1 2 4 3<br>首先Promise新建后立即执行，所以会先输出1,2，而Promise.then()内部的代码在当次事件循环的结尾立即执行，所以会先输出4，最后输出3.</p>
<p>题目二<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&apos;success1&apos;);</span><br><span class="line">    reject(&apos;error&apos;);</span><br><span class="line">    resolve(&apos;success2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">    console.log(&apos;then:&apos;, res);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&apos;catch:&apos;, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>答案：then：success1</p>
<p>promise状态一经改变，不会再被改变其他的会被忽略。then函数会把上一个promise的值传递过来所以结果是：then：success1。</p>
<p>题目三<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .then(console.log)</span><br></pre></td></tr></table></figure></p>
<p>答案：1<br>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。<br>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p>
<p>题目四<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(7);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(5);</span><br><span class="line">            resolve(6);</span><br><span class="line">        &#125;, 0)</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(2);</span><br><span class="line">    p.then((arg) =&gt; &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">first().then((arg) =&gt; &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure></p>
<p>答案：<br>3 7 4 1 2 5</p>
<p>结合js event loop 机制，同步任务在执行过程中遇到异步任务会将其放入异步任务队列，在同步任务队列执行完毕之后再执行异步任务，异步任务执行完毕后再返回同步任务队列执行。异步任务分为宏仁务和微任务，微任务总是在宏仁务之前执行。</p>
<p>微任务： promise.then promise.catch promise.finally MutaionObserver process.nextTick(nodejs)<br>宏仁务： setTimeOut setInterval I/O setImmediate requestAnimationFrame</p>
<p>promise 定义时是同步执行，promise状态修改完毕之后不会再被修改。所以结果为3 7 4 1 2 5 没有6；</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

